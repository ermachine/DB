## Семинар 3. Проектирование, нормальные формы, версионирование

### 1. Проектирование

#### 1.1. Основные этапы проектирования

##### 1.1.1. Концептуальное проектирование

1. Определяем предметную область, с которой будем работать.

**Примеры:**
* Киносервис
* Ритейл
* Отельное агентство
* Образовательная платформа
* Персонал фирмы
        

2. Разбиваем на недетализированные сущности.

Например, для киносервиса можно выделить:
* Пользователи
* Сессии на платформе
* Фильмы
* Авторы
        

3. Определяем, как сущности будут друг с другом связаны.

Они могут иметь отношение "один к одному", "один ко многим" и другие - детальнее будет рассмотрено далее.

**Примеры:**
* Сущности отельного агентства "Отель" и "Фотографии отеля" имеют отношение *"один ко многим"*
* Сущности ритейла "Поставщик" и "Склад" имеют отношение *"один к одному"*
* Сущности образовательной платформы "Учебный курс" и "Покупатель" имеют отношение *"многие ко многим"*
    

4. Строим визуальную картину в ER-нотации (Entity-Relationship notation) "Воронья лапка" (Crow's Foot) без явных атрибутов. На этом этапе нам нужно выделить сущности в виде блоков и связать их между собой.

**Нотация "Воронья лапка"**

* Сущность изображается в виде прямоугольника, содержащего ее имя.
* Атрибуты сущности записываются внутри прямоугольника, изображающего сущность.
* Связь изображается линией, которая соединяет две сущности, участвующие в отношении.
* Множественность связи изображается в виде вилки.

![](images/img_3.png)

![](images/img_2.png)

Выше показана связь сущностей Artist и Song: песня (Song) имеет «одного и только одного» исполнителя (Artist); исполнитель связан с «нулем, одной или несколькими» песнями.

##### 1.1.2. Логическое проектирование

1. Разбиваем недетализированные сущности на детализированные согласно выбранной модели данных и нормализации.

Например, в области "Персонал фирмы" в сущности "Сотрудник" нет необходимости хранить вместе его зарплату, должность, персональные данные целиком одним блоком. Для этого можно разбить сущность на более мелкие.

Мотивация такого подхода - устранение избыточности данных (разбиение на логические части), безопасность доступа (можно разрешить пользователю СУБД иметь доступ только к некоторым таблицам, и таким образом ограничить его доступ к зарплате или персональным данным) и более простая поддержка в случае изменений данных (например, в сущности "Производитель" достаточно хранить только его *"Город"*, без *"Страны"*, т.к. у города случайно может поменяться страна, и в случае изменений придется пересчитывать таблицу полностью)

2. Определяем атрибуты.

Для каждой детализированной сущности определяем, что мы собираемся хранить.

3. Определяем связи между сущностями по атрибутам.

После того, как определили атрибуты для каждой сущности, нужно явно указать, по каким полям происходит связь. Это в частности позволит определить вторичные ключи, чтобы их указать при создании таблиц.

4. Строим визуальную картину в ER-нотации с явными атрибутами.

Переносим все детализированные изменения на визуальную картину.

##### 1.1.3. Физическое проектирование

Физическое проектирование — создание схемы базы данных внутри конкретной СУБД. 
Специфика СУБД может включать в себя ограничения на именование объектов базы данных, 
ограничения на поддерживаемые типы данных и тому подобное. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, 
разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и так далее.

*Результатом* физического проектирования логической схемы может быть SQL-скрипт инициализации таблицы и/или готовая таблица с описанием каждой сущности. 

**Пример**:   
SQL скрипт:
```sql
CREATE TABLE IF NOT EXISTS STUDENT (
    STUDENT_ID   INTEGER      PRIMARY KEY,
    STUDENT_NAME VARCHAR(128) NOT NULL,
    ... 
);
...
```
И табличка с описанием:  

**STUDENT**

| Название       | Описание      | Тип данных     | Ограничение   |
|----------------| ------------- | -------------- | --------------|
| `STUDENT_ID`   | Идентификатор | `INTEGER`      | `PRIMARY KEY` |
| `STUDENT_NAME` | Имя студента  | `VARCHAR(128)` | `NOT NULL`    |
| ...            | ...           | ...            | ...           |


#### 1.2. ER-диаграммы

Модель «сущность-связь» (Entity-Relationship Model, ER-model) – одна из наиболее известных и получивших широкое распространение моделей семантического моделирования – разработана П. Ченом в 1976 году.

Основные элементы ER-модели:
* Сущность (entity) – это предмет, который может быть идентифицирован некоторым способом, отличающим его от других предметов.
* Атрибут – свойство сущности (как, правило, атомарное).
* Ключевый атрибут – уникальный атрибут, однозначно идентифицирующий экземпляр сущности.
* Связь (relationship) – это ассоциация, устанавливаемая между сущностями. Степень связи – количество связанных сущностей.

Выделяют следующие нотации ER-диаграмм:
* классическая нотация П. Чена;
* нотация IDEFIX (Integration Definition for Information Modeling);
* нотация Ч. Бахмана;
* нотация Дж. Мартина («вороньи лапки»);
* нотация Ж.-Р. Абриаля (минмакс);
* диаграммы классов UML.

При построении ER-модели важно различать типы бинарных связей, выделяют 4 типа:
* "**Ноль или более**";
* "**Один или более**";
* "**Только один**";
* "**Ноль или один**".

![](images/img_4.png)

Каждая из них показывает, сколько значений из первой таблицы может находиться во второй таблице (это может быть непонятно при первом прочитывании; стоит вернуться после примера, рассмотренного далее). Тип связи определяется для обоих концов, то есть существует $\frac{4 \cdot 3}{2} + 4 = 10$ возможных связей ($\frac{4 \cdot 3}{2}$ связей с разными концами и 4 связи с одинаковыми концами).

На практике чаще всего реализуют следующие 3:

* "**Один-к-одному**" (One-to-One) - Каждая запись в первой таблице соответствует одной и только одной записи во второй таблице и наоборот.

* "**Один-ко-многим**" (One-to-Many) - Каждая запись в первой таблице соответствует одной или более записям во второй таблице, но каждая запись во второй таблице связана только с одной записью из первой таблицы.

* "**Много-ко-многим**" (Many-to-Many) - Записи в первой таблице могут быть связаны с многими записями во второй таблице и наоборот. Реализуется с помощью промежуточной таблицы (также известной как таблица связей или ассоциативная таблица).

Разберемся на **примере** отельного агентства. Рассмотрим сущности:

* Отель
* Отельная сеть (Azimut Hotels, Cosmos Hotel Group, ...)

1. Связь "*Отель*" - "*Отельная сеть*"

У фиксированного отеля может быть 0 или 1 отельная сеть, которой он принадлежит и под маркой которой он продается. При этом если мы рассмотрим какую-нибудь отельную сеть, то ей может принадлежать несколько отелей (причем если их 0, то можно как хранить эту сеть в таблице, так и не хранить - в зависимости от целей и наших желаний). Это значит, что "*Отель*" реализуется в "*Отельная сеть*" как "**Ноль или один**", а "*Отельная сеть*" реализуется в "*Отель*" как "**Ноль (Один) или более**".

Визуально эта связь реализуется так:

![](images/hotel_example.png)

**Важно понимать**, что в *PostgreSQL*, как и в некоторых других СУБД, реализовать связь много-ко-многим напрямую невозможно (или по крайней мере проблематично).

Для этого рассмотрим **демонстративный пример**:

Есть 2 сущности:
1. *Студент*
2. *Учебный курс*

![](images/student_course.png)

Каждая из них реализована в виде одной таблицы, пусть studentId и courseId - соответственно первичные ключи в этих таблицах. В таблице "*Студент*", чтобы не нарушать структуру и форму первичного ключа, список курсов нужно хранить в виде списка. В таком случае не ясно, есть ли здесь вторичный ключ, и как джойнить эти таблицы.

Для понятного указания СУБД, что есть первичный и вторичный ключ, courseId_list и studentId_list разворачивают в строки и помещают в отдельную, третью таблицу:

![](images/student_course_upd.png)

Таким образом, все проблемы в реализации и неоднозначности решаются.





**Пример ER-диаграммы для логической модели**:

![](images/img_5.png)

ER-диаграммы можно рисовать в [gliffy](https://www.gliffy.com/) или [draw.io](https://app.diagrams.net/). Нужно создать новый документ и выбрать нужный тип диаграммы.

---

### 2. Нормальные формы

**Нормальная форма:**

На этапе создания базы данных мы определяем список требований к отношению и таблицам. Список этих требований задается *Нормальной формой* (НФ).


Нормальная форма — это свойство отношения в реляционной модели данных, которое помогает определить уровень избыточности данных и которое направлено на устранение функциональной зависимости, улучшение логической структуры данных и повышение целостности данных. Существует несколько *Нормальных форм*. Отсутствие нормализации может привести к аномалиям при вставке, обновлении и удалении данных, что потенциально приводит к логически ошибочным результатам выборки или изменения данных.


**Нормализация БД** — приведение БД к нормальной форме;
* Предназначена для:
    * Минимизации логической избыточности;
    * Уменьшения потенциальной противоречивости → устранение некоторых _аномалий_ обновления;
    * Разработки проекта БД, который является:
        * качественным представлением реального мира;
        * интуитивно понятным;
        * легко расширяемым в дальнейшем.
    * Упрощения процедуры применения необходимых ограничений целостности.
* Не предназначена для:
    * Изменения производительности БД;
    * Изменения физического объема БД.
* Производится за счет декомпозиции (разложения исходной переменной отношения на несколько эквивалентных) отношения:
    * декомпозиция без потерь (правильная) — обратимая декомпозиция.
* Польза:
    * Позволяет проектировать неплохие БД на первых порах.
    * Помогает избегать типичных ошибок при проектировании БД людям без опыта.
    * Формирует привычку делать нормально сразу, не оставляя на потом.
    * Постепенно вырабатывает навык проектирования, без прочной завязки на нормальных формах.

**Аномалия** — ситуация в таблице БД, возникшая из-за излишнего дублирования в таблице, такая, что:
* Существенно осложнена работа с БД;
* В БД присутствуют противоречия.

**Нормальные формы:**
1. *Первая нормальная форма (1NF)*:
    * Значения всех атрибутов отношения атомарны (все атрибуты простые, содержат только скалярные значения):

![](images/img_nf1.png)

2. *Вторая нормальная форма (2NF)*:
    * 1NF (атомарность атрибутов) + каждый неключевой атрибут функционально полностью зависит от потенциального ключа (1NF всегда можно привести к 2NF, и этот процесс обратим):

Здесь автор слов и композитор зависят только от полей “Название группы” и “Название песни”, то есть от подмножества PK (от того, что песня включена в другой CD-диск, автор слов и композитор не изменятся)

![](images/img_nf2.png)

3. *Третья нормальная форма (3NF)*:
    * 2NF (атомарность атрибутов, минимальная функциональная зависимость от PK) + каждый неключевой атрибут нетранзитивно функционально зависит от первичного ключа (то есть каждое неключевое поле полностью и единственный образом определяется ключом, полным ключом и ни от чего более не зависит)

Здесь присутствуют функциональные зависимости:
* Сотрудник → Отдел
* Отдел → Телефон
* Сотрудник →Телефон

![](images/img_nf3.png)

Разбиваем таблицу так, чтобы избавиться от транзитивности: разносим атрибуты "Сотрудник" и "Телефон" по разным отношениям.

4. *Нормальная форма Бойса-Кодда (BCNF)*
5. *Четвертая нормальная форма (4NF)*
6. *Пятая нормальная форма / Нормальная форма проекции-соединения (5NF / PJNF)*
7. *Доменно-ключевая нормальная форма (DKNF)*
8. *Шестая нормальная форма (6NF)*

**Функциональная зависимость** между множествами атрибутов X и Y означает,  что для любого допустимого набора кортежей в данном отношении верно следующее: если два кортежа совпадают по значению X, то они совпадают по значению Y.

**Минимальная функциональная зависимость** — ни для одного из атрибутов мы не можем выделить подмножество в потенциальном ключе, такое, чтобы атрибут от него функционально зависел.

---

### 3. Версионирование

#### 3.1. SCD. Типы SCD

**SCD (Slowly Changing Dimension)** —  редко изменяющиеся измерения, то есть измерения, не ключевые атрибуты которых имеют тенденцию со временем изменяться.

Выделяют пять основных типов:

* **SCD 0**: после попадания в таблицу данные никогда  не изменяются — не поддерживает версионность. Практически никогда не используется.
* **SCD 1**: данные перезаписываются (всегда актуальные) — используется, если история не нужна.

    * _Достоинства:_
        * Не добавляет избыточность
        * Очень простая структура

    * _Недостатки:_
        * Не хранит историю

* **SCD 2**: храним историю с помощью двух полей (дата начала действия, дата окончания действия: `valid_from`, `valid_to`) — _используется наиболее часто_.

    * _Достоинства:_
        * Хранит полную и неограниченную историю версий
        * Удобный и простой доступ к данным необходимого периода

    * _Недостатки:_
        * Провоцирует на избыточность или заведение доп. таблиц для хранения изменяемых атрибутов
        * Требует добавление техничеких полей, что немного захламляет общую таблицу
        * В случае обращения только к актуальным данным придется фильтровать таблицу, что может быть очень долгим процессом

![](images/img_scd2.png)

Вместо `NULL` используется некоторая константа (для `valid_to — '9999-12-31'`), что позволяет писать простое условие:
```sql
WHERE day_dt BETWEEN valid_from_dttm AND valid_to_dttm
```
вместо
```sql
WHERE day_dt >= valid_from_dttm
    AND (day_dt <= valid_to_dttm
        OR valid_to_dttm IS NULL)
```

* **SCD 3**: храним старое значение для выделенных атрибутов в отдельных полях. При получении новых данных старые данные перезаписываются текущими значениями.
    * _Достоинства:_
        * Небольшой объем данных
        * Простой и быстрый доступ к истории
    * _Недостатки:_
        * Ограниченная история
        * Требует добавления технического поля в общую таблицу

![](images/img_scd3.png)

* **SCD 4**: храним в основной таблице только актуальные данные и историю изменений в отдельной таблице. Основная таблица всегда перезаписывается текущими данными с перенесением старых данных в другую таблицу. Обычно этот тип используют для аудита изменений или создания архивных таблиц.
    * _Достоинства:_
        * Быстрая работа с текущими версиями
        * Сохраняет PK и структуры таблицы в актуальном, легко интерпретируемом виде без лишней информации, что позволяет удобно на нее ссылаться
        * Удобное хранение истории в одном месте в удобном виде
    * _Недостатки:_
        * Разделение единой сущности на разные таблицы
        * Хранение часто меняющихся данных требует большой объем памяти

![](images/img_scd4.png)

**Важно понимать, что версионирование, как и нормальная форма, внутри базы данных может отличаться для разных таблиц. Выбирать их нужно исходя из нужд, доступных ресурсов и особенности хранимых данных.**

---

### 4. Практическое задание

Для каждой из следующих предметных областей

* Физтех. Ключевые сущности: физтех-школа, кафедра, студент, преподаватель, аудитория, расписание занятий.
* Розничная сеть магазинов. Ключевые сущности: магазин, сотрудник, товар, чек, карта лояльности, кассовый аппарат.

требуется:

1. спроектировать концептуальные базы данных;

2. выбрать нормальную форму и версионность;

3. описать спроектированные модели с помощью языка запросов SQL;

4. придумать 3 осмысленных SQL-запроса с использованием JOIN и как минимум 1 запрос с обращением к историчным данным.


Предоставим **некоторые наброски решения** для предметной области "*Физтех*". На семинаре и в домашнем проекте требуется сделать более полную работу.

1. Концептуальная схема

![](images/conceptual.png)

2. Логическая схема

![](images/logical.png)

Здесь для employee применено версионирование SCD 4, для остального - SCD 1. По хорошему для других таблиц по возможности нужно сделать так же SCD 4 (например, для phsytech_school, student).

Везде применена 3 НФ.

3. Физическая схема

```sql
CREATE TABLE IF NOT EXISTS phystech_school (
    phystech_school_name        VARCHAR(128)    PRIMARY KEY,
    manager_name                VARCHAR(128)    NOT NULL,
    foundation_dt               VARCHAR(128)    NOT NULL
);

CREATE TABLE IF NOT EXISTS department (
    department_name             VARCHAR(128)    PRIMARY KEY,
    location_auditorium_id      VARCHAR(128)    NOT NULL
);

CREATE TABLE IF NOT EXISTS employee (
    employee_name               VARCHAR(128)    PRIMARY KEY,
    position                    VARCHAR(128)    NOT NULL,
    birthday_dt                 DATE,
    department_name             VARCHAR(128),
    wikimipt_link_url           VARCHAR(128),
    FOREIGN KEY (department_name) REFERENCES department(department_name)
);

CREATE TABLE IF NOT EXISTS employee_history (
    id                          INT AUTO_INCREMENT PRIMARY KEY,
    employee_name               VARCHAR(128)       NOT NULL,
    position                    VARCHAR(128),
    birthday_dt                 DATE,
    department_name             VARCHAR(128),
    wikimipt_link_url           VARCHAR(128),
    date_from                   DATE NOT NULL,
    date_to                     DATE,
    FOREIGN KEY (employee_name) REFERENCES employee(employee_name),
    FOREIGN KEY (department_name) REFERENCES department(department_name)
);

CREATE TABLE IF NOT EXISTS course (
    course_id                   INT AUTO_INCREMENT PRIMARY KEY,
    course_name                 VARCHAR(128)       NOT NULL,
    department_name             VARCHAR(128),
    FOREIGN KEY (department_name) REFERENCES department(department_name)
);

CREATE TABLE IF NOT EXISTS teacher_course (
    teacher_name                VARCHAR(128),
    course_id                   INT,
    PRIMARY KEY (teacher_name, course_id),
    FOREIGN KEY (teacher_name) REFERENCES employee(employee_name),
    FOREIGN KEY (course_id) REFERENCES course(course_id)
);

CREATE TABLE IF NOT EXISTS student (
    student_name                VARCHAR(128) PRIMARY KEY,
    birthday_dt                 DATE,
    group_id                    INT NULL,
    department_name             VARCHAR(128),
    admission_dt                DATE,
    average_mark                DECIMAL(3,2),
    -- будем считать в данной моделе балл фиксированным
    scholarship                 DECIMAL(8,2),
    fee                         DECIMAL(8,2),
    FOREIGN KEY (department_name) REFERENCES department(department_name)
);

CREATE TABLE IF NOT EXISTS group (
    group_id                    INT AUTO_INCREMENT PRIMARY KEY,
    phystech_school             VARCHAR(128)       NOT NULL,
    head_student_name           VARCHAR(128)       NOT NULL,
    group_size                  INT                NOT NULL,
    FOREIGN KEY (phystech_school) REFERENCES phystech_school(phystech_school_name),
    FOREIGN KEY (head_student_name) REFERENCES student(student_name)
);

CREATE TABLE IF NOT EXISTS auditorium (
    auditorium_id       INT AUTO_INCREMENT PRIMARY KEY,
    building_number     VARCHAR(128),
    auditorium_size     INT  -- большая, средняя или маленькая
);

CREATE TABLE IF NOT EXISTS schedule (
    id                  INT AUTO_INCREMENT PRIMARY KEY,
    start_dt            DATE               NOT NULL,
    end_dt              DATE               NOT NULL,
    teacher_name        VARCHAR(128)       NOT NULL,
    default_group_id    INT                NOT NULL,
    auditorium_id       INT                NOT NULL,
    FOREIGN KEY (teacher_name) REFERENCES employee(employee_name),
    FOREIGN KEY (default_group_id) REFERENCES group(group_id),
    FOREIGN KEY (auditorium_id) REFERENCES auditorium(auditorium_id)
);
```

Написать самостоятельно следующие запросы:

1. Посчитать количество студентов, которые изучают курс "Базы данных"

2. Вывести старост групп, которые изучают хотя бы один курс, который ведет "Иванов Александр Максимович"

3. Вывести список аудиторий, в которых в понедельник проходит курс "Теория вероятностей" (обратить внимание, что один курс может читаться разными кафедрами, поэтому *course_name* не может быть первичным ключом).

4. Вывести количество преподавателей, которые меняли свою кафедру.
